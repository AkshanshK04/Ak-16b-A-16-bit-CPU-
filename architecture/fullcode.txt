//alu.v
`include "def_opcode.v"

module alu(
    input [15:0] a, b,
    input [3:0] alu_op,
    output reg [15:0] alu_result,
    output zero
);

    

    always @(*) begin
        alu_result = 16'd0;
        
        case(alu_op)
            `ALU_ADD: alu_result = a+b ;
            `ALU_SUB: alu_result = a-b;
            `ALU_AND: alu_result = a&b;
            `ALU_OR: alu_result= a |b;
            `ALU_XOR: alu_result = a ^b;
            `ALU_SLT: alu_result = ($signed(a) < $signed(b) ) ? 16'd1 : 16'd0;
            default: alu_result = 16'd0;
        endcase
    end

    assign zero = (alu_result == 16'b0);
endmodule

//control.v
`include "def_opcode.v"

module control (
    input wire [3:0] opcode,
    input wire zero,
    input wire stall,
    output reg reg_write ,
    output reg alu_src ,
    output reg mem_read,
    output reg mem_write,
    output reg mem_to_reg,
    output reg branch,
    output reg branch_ne,
    output reg pc_write,
    output reg halt,
    output reg [3:0] alu_op
);

    always @(*) begin
        // Default values
        reg_write = 0;
        alu_src = 0;
        mem_read=0;
        mem_write=0;
        mem_to_reg=0;
        branch = 0;
        branch_ne =0;
        pc_write = 1;
        alu_op = `ALU_ADD;
        halt =0;

        //freeze pc if stall
        if (stall)
            pc_write = 0;

        case (opcode)

            //R type
            `OP_ADD : begin reg_write=1; alu_op=`ALU_ADD; end
            `OP_SUB : begin reg_write=1; alu_op=`ALU_SUB;  end
            `OP_AND : begin reg_write=1; alu_op=`ALU_AND; end
            `OP_OR  : begin reg_write=1; alu_op=`ALU_OR;  end
            `OP_XOR : begin reg_write=1; alu_op=`ALU_XOR; end
            `OP_SLT : begin reg_write=1; alu_op=`ALU_SLT;  end

            //I type
            `OP_ADDI : begin reg_write=1; alu_op=`ALU_ADD; alu_src=1; end 
            `OP_ANDI : begin reg_write=1; alu_op=`ALU_AND; alu_src=1; end
            `OP_ORI : begin reg_write=1; alu_op=`ALU_OR; alu_src=1; end
            `OP_XORI : begin reg_write=1; alu_op=`ALU_XOR; alu_src=1; end

            // Memory
            `OP_LW : begin reg_write=1;  alu_src=1; mem_read=1; mem_to_reg=1; end
            `OP_SW : begin  alu_src=1; mem_write=1; end
            
            `OP_BEQ : begin
                branch =zero ? 1'b1 : 1'b0 ; 
                alu_op=`ALU_SUB; 
                reg_write = 1'b0;
                end

            `OP_BNE : begin 
                branch_ne = ~zero ? 1'b1 : 1'b0 ; 
                alu_op=`ALU_SUB; 
                reg_write = 1'b0; 
                end

            `OP_HALT : begin halt = 1'b1; end
            default : begin //nop
                end
        endcase
    end
endmodule

//cputbpipeline.v
`timescale  1ns/1ns

module cpu_tb_pipeline;
    reg clk;
    reg rst;

    cpu_top_pipeline dut (
        .clk(clk),
        .rst(rst)
    );

    initial begin
        clk=0;
        forever #5 clk = ~clk;
    end

    initial begin 
        $dumpfile("cpu_pipeline.vcd");
        $dumpvars(0, cpu_tb_pipeline);
    end

    initial begin
        rst = 1 ;
        #20;
        rst =0;
    end

    initial begin
        $display("\n=== AK-16 PIPELINE CPU SIM START ===\n");
        $monitor(
            "T=%0t | IF_PC=%h | ID_INSTR=%h | EX_RD=%h | WB_RD=%h | WB_W=%b",
            $time,
            dut.if_pc,
            dut.id_instr,
            dut.ex_rd,
            dut.wb_rd,
            dut.wb_reg_write
        );
    end

    initial begin
        #3000;
        dump_state();
        $finish;
    end

    always @(posedge clk ) begin
        if (dut.halted && !rst) begin
            $display("\n=== HALT DETECTED ===");
            dump_state();
            #20;
            $finish;
        end
    end

    task dump_state;
        integer i ;
        begin
            $display("\n=== REGISTER FILE ===");
            for (i = 0; i < 16; i = i + 1)
                $display("R%0d = %04h (%0d)",
                         i,
                         dut.u_rf.regs[i],
                         $signed(dut.u_rf.regs[i]));

            $display("\n=== DATA MEMORY [0..7] ===");
            for (i = 0; i < 8; i = i + 1)
                $display("mem[%0d] = %04h",
                         i,
                         dut.u_dmem.mem[i]);
        end
    endtask

endmodule

//cputoppipeline.v
`timescale 1ns/1ns

module cpu_top_pipeline (
    input wire clk,
    input wire rst
);
    wire [15:0] ex_pc ;
    wire [15:0] ex_branch_target;
    assign ex_branch_target = ex_pc + ex_imm;

    //reg for halt
    reg halted;

    //if stage wiring
    wire [15:0] if_pc;
    wire [15:0] if_instr;

    always @(posedge clk or posedge rst) begin
        if (rst) 
            halted <= 1'b0;
        else if (id_opcode == `OP_HALT)
            halted <= 1'b1;
    end 


    //HALT Latch
    always @(posedge clk or posedge rst ) begin
        if (rst)
            halted <= 1'b0;
        else if (id_halt)
            halted <= 1'b1;
    end

    wire branch_taken;
    wire [15:0] branch_target;

    if_stage u_if (
        .clk(clk),
        .rst(rst),
        .stall_if(halted)  ,   // for hazard
        .flush_if(branch_taken),
        .halt(id_halt),
        .branch_taken(branch_taken),
        .branch_target(branch_target),
        .if_pc(if_pc),
        .if_instr(if_instr)
    );

    //iF/ID pipeline regsiter
    wire [15:0] id_pc;
    wire [15:0] id_instr;

    pipe_if_id u_if_id (
        .clk(clk),
        .rst(rst),
        .stall_id(halted),
        .flush_id(branch_taken),
        .if_pc(if_pc),
        .if_instr(if_instr),
        .id_pc(id_pc),
        .id_instr(id_instr)
    );

    //IDstage + control 
    wire [3:0] id_opcode = id_instr[15:12];
    wire [3:0] id_rd = id_instr[11:8];
    wire [3:0] id_rs1 = id_instr[7:4];
    wire [3:0] id_rs2 = id_instr[3:0];
    wire [15:0] id_imm = {{12{id_instr[3]}}, id_instr[3:0]};

    // control signals
    wire id_reg_write, id_alu_src;
    wire id_mem_read, id_mem_write, id_mem_to_reg;
    wire id_branch , id_branch_ne;
    wire [3:0] id_alu_op;
    wire id_halt;

    control u_ctrl(
        .opcode(id_opcode),
        .reg_write(id_reg_write),
        .alu_src(id_alu_src),
        .mem_read(id_mem_read),
        .mem_write(id_mem_write),
        .mem_to_reg(id_mem_to_reg),
        .branch(id_branch),
        .branch_ne(id_branch_ne),
        .pc_write(),
        .alu_op(id_alu_op),
        .halt(id_halt)
    );

    //regfile
    wire [15:0] id_rs1_data, id_rs2_data;
    wire [15:0] wb_data;
    wire wb_reg_write;
    wire [3:0] wb_rd;

    regfile u_rf(
        .clk(clk),
        .rst(rst),
        .reg_write(wb_reg_write),
        .rs1(id_rs1),
        .rs2(id_rs2),
        .rd(wb_rd),
        .rd_data(wb_data),
        .rs1_data(id_rs1_data),
        .rs2_data(id_rs2_data)
    );

    //ID/EX pipeline register
    wire [15:0] ex_rs1_data , ex_rs2_data, ex_imm;
    wire [3:0] ex_rd;
    wire ex_reg_write , ex_alu_src;
    wire ex_mem_read; 
    wire ex_mem_write, ex_mem_to_reg;
    wire ex_branch, ex_branch_ne;
    wire [3:0] ex_alu_op;

    pipe_id_ex u_id_ex(
        .clk(clk),
        .rst(rst),
        .stall_ex(halted),
        .flush_ex(branch_taken),

        .id_rs1_data(id_rs1_data),
        .id_rs2_data(id_rs2_data),
        .id_imm(id_imm),
        .id_rd(id_rd),
        .id_pc(id_pc),

        .id_reg_write(id_reg_write),
        .id_alu_src(id_alu_src),
        .id_mem_read(id_mem_read),
        .id_mem_write(id_mem_write),
        .id_mem_to_reg(id_mem_to_reg),
        .id_branch(id_branch),
        .id_branch_ne(id_branch_ne),
        .id_alu_op(id_alu_op),

        .ex_rs1_data(ex_rs1_data),
        .ex_rs2_data(ex_rs2_data),
        .ex_imm(ex_imm),
        .ex_rd(ex_rd),
        .ex_pc(ex_pc),

        .ex_reg_write(ex_reg_write),
        .ex_alu_src(ex_alu_src),
        .ex_mem_read(ex_mem_read),
        .ex_mem_write(ex_mem_write),
        .ex_mem_to_reg(ex_mem_to_reg),
        .ex_branch(ex_branch),
        .ex_branch_ne(ex_branch_ne),
        .ex_alu_op(ex_alu_op)
    );

    //EX-1
    wire [15:0] ex1_alu_in1, ex1_alu_in2;

    ex1_stage u_ex1(
        .clk(clk),
        .rst(rst),
        .ex_rs1_data(ex_rs1_data),
        .ex_rs2_data(ex_rs2_data),
        .ex_imm(ex_imm),
        .ex_alu_src(ex_alu_src),
        .alu_in1(ex1_alu_in1),
        .alu_in2(ex1_alu_in2)
    );

    // EX-2
    wire [15:0] ex2_alu_result;
    wire ex2_zero;

    ex2_stage u_ex2 (
        .clk(clk),
        .rst(rst),
        .alu_in1(ex1_alu_in1),
        .alu_in2(ex1_alu_in2),
        .alu_op(ex_alu_op),
        .alu_result(ex2_alu_result),
        .zero(ex2_zero)
    );

    // ex-mem pipe
    wire [15:0] mem_alu_result, mem_rs2_data;
    wire [3:0] mem_rd;
    wire mem_reg_write, mem_mem_read, mem_mem_write, mem_mem_to_reg;
    wire mem_branch, mem_branch_ne, mem_zero;
    wire [15:0] mem_branch_target;

    pipe_ex2_mem u_ex_mem (
        .clk(clk),
        .rst(rst),
        .flush_mem(branch_taken),

        .ex2_alu_result(ex2_alu_result),
        .ex2_rs2_data(ex_rs2_data),
        .ex2_rd(ex_rd),
        .ex2_branch_target(ex_branch_target),

        .ex2_reg_write(ex_reg_write),
        .ex2_mem_read(ex_mem_read),
        .ex2_mem_write(ex_mem_write),
        .ex2_mem_to_reg(ex_mem_to_reg),
        .ex2_branch(ex_branch),
        .ex2_branch_ne(ex_branch_ne),
        .ex2_zero(ex2_zero),

        .mem_alu_result(mem_alu_result),
        .mem_rs2_data(mem_rs2_data),
        .mem_rd(mem_rd),
        .mem_branch_target(mem_branch_target),

        .mem_reg_write(mem_reg_write),
        .mem_mem_read(mem_mem_read),
        .mem_mem_write(mem_mem_write),
        .mem_mem_to_reg(mem_mem_to_reg),
        .mem_branch(mem_branch),
        .mem_branch_ne(mem_branch_ne),
        .mem_zero(mem_zero)
    );

    // mem stage
    wire [15:0] mem_read_data;
    dmem u_dmem (
        .clk(clk),
        .addr(mem_alu_result),
        .wdata(mem_rs2_data),
        .mem_write(mem_mem_write),
        .mem_read(mem_mem_read),
        .rdata(mem_read_data)
    );

    // mem-wb pipe
    wire [15:0] wb_alu_result, wb_read_data ;
    wire wb_mem_to_reg ;
    
    pipe_mem_wb u_mem_wb (
        .clk(clk),
        .rst(rst),
        .flush_wb(branch_taken),
        .mem_alu_result(mem_alu_result),
        .mem_read_data(mem_read_data),
        .mem_rd(mem_rd),
        .mem_reg_write(mem_reg_write),
        .mem_mem_to_reg(mem_mem_to_reg),
        .wb_alu_result(wb_alu_result),
        .wb_read_data(wb_read_data),
        .wb_rd(wb_rd),
        .wb_reg_write(wb_reg_write),
        .wb_mem_to_reg(wb_mem_to_reg)
    );

    // wb stage
    assign wb_data = wb_mem_to_reg ? wb_read_data : wb_alu_result;

    // branch decision
    assign branch_taken = (mem_branch && mem_zero) || (mem_branch_ne && !mem_zero);
    assign branch_target = mem_branch_target; //
endmodule


//defopcode.v
`ifndef AK16_OPCODE_V
`define AK16_OPCODE_V
//let me define opcodes for ak-16bit

// AK-16b cpu opcodes

//Instruction format:
// [15:12] - Opcode , [11:8] - rd, [7:4] - rs1, [3:0] - rs2/ imm
//System
//`define OP_NOP 4'h0
`define OP_HALT 4'hF

//R-type 
`define OP_ADD 4'h0
`define OP_SUB 4'h1
`define OP_AND 4'h2
`define OP_OR 4'h3
`define OP_XOR 4'h4
`define OP_SLT 4'h5

//I-type
`define OP_ADDI 4'h6
`define OP_ANDI 4'h7
`define OP_ORI 4'h8
`define OP_XORI 4'h9
//Memory
`define OP_LW 4'hA
`define OP_SW 4'hB

//control flow
`define OP_BEQ 4'hC
`define OP_BNE 4'hD
`define OP_JUMP 4'hE
//4'hF is reserved for HALT


//ALU OP defs
`define ALU_ADD 4'b0000
`define ALU_SUB 4'b0001
`define ALU_AND 4'b0010
`define ALU_OR 4'b0011
`define ALU_XOR 4'b0100
`define ALU_SLT 4'b0101
`endif 

//dmem.v
module dmem(
    input wire clk,
    input wire rst,
    input wire [15:0] addr,
    input wire [15:0] wdata,
    input wire mem_write,
    input wire mem_read,
    output reg [15:0] rdata
);

    reg [15:0] mem [0:255];  //256 x 16-b memory
    integer i;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i=0; i<256; i=i+1)
                mem[i] <= 16'd0;
            rdata <= 16'd0;
        end
        else begin
            if (mem_write) 
                mem[addr[7:0]] <= wdata;

            if (mem_read)
                rdata <= mem[addr[7:0]];
            else 
                rdata <= 16'd0;
        end
    end

endmodule

//ex1stage.v
`timescale 1ns/1ns

module ex1_stage(
    input wire clk,
    input wire rst,

    //from id/ex pipeline
    input wire [15:0] ex_rs1_data,
    input wire [15:0] ex_rs2_data,
    input wire [15:0] ex_imm,
    input wire ex_alu_src,      // 0=rs2, 1=imm

    //forwarding unit 
    input wire [15:0] exmem_alu_result,
    input wire [15:0] memwb_wb_data,

    //forwarding control
    input wire [1:0] forward_a,
    input wire [1:0] forward_b,

    output reg [15:0] alu_in1,
    output reg [ 15:0] alu_in2
);

    reg [15:0] src_a;
    reg [15:0] src_b;
    

    //forwarding mux for rs1
    always @(*) begin
        case(forward_a)
            2'b00 : src_a = ex_rs1_data;
            2'b01 : src_a = memwb_wb_data;
            2'b10 : src_a = exmem_alu_result;
            default : src_a = ex_rs1_data;
        endcase
    end

    //forwarding mux for rs2
    always @(*) begin
        case(forward_b) 
            2'b00 :  src_b = ex_rs2_data;
            2'b01 : src_b = memwb_wb_data;
            2'b10 : src_b = exmem_alu_result;
            default : src_b = ex_rs2_data;
        endcase
    end

    always @(*) begin
        alu_in1 = src_a;
        alu_in2 = (ex_alu_src) ? ex_imm : src_b;
    end
endmodule

//ex2stage.v
`timescale 1ns/1ns

module ex2_stage(
    input clk,
    input rst,
    input wire [15:0] alu_in1,
    input wire [15:0] alu_in2,
    input wire [3:0] alu_op,
    output reg [15:0] alu_result,
    output reg zero
);

    always @(*) begin
        case(alu_op)
            `ALU_ADD : alu_result = alu_in1 + alu_in2;
            `ALU_SUB : alu_result = alu_in1 - alu_in2;
            `ALU_AND : alu_result = alu_in1 & alu_in2;
            `ALU_OR : alu_result = alu_in1 | alu_in2 ;
            `ALU_XOR : alu_result = alu_in1 ^ alu_in2;
            `ALU_SLT : alu_result = ($signed(alu_in1) < $signed(alu_in2) ) ? 16'b1 : 16'b0;
            default : alu_result = 16'b0;
    endcase

    zero = (alu_result == 16'b0) ;
    end
endmodule

//forwardingunit.v
module forwarding_unit (
    //source regs from id/ex
    input wire [3:0] idex_rs1,
    input wire [3:0] idex_rs2,

    //ex/mem stage info
    input wire exmem_reg_write,
    input wire [3:0] exmem_rd,

    //mem/wb stage info
    input wire memwb_reg_write,
    input wire [3:0] memwb_rd,

    //forwarding control ops
    //00 = no forward, 10= from ex/mem , 01= from mem/wb
    output reg [1:0] forward_a,
    output reg [1:0] forward_b 
);

    always @(*) begin
        //default : no forwarding
        forward_a = 2'b00;
        forward_b = 2'b00;

        // ex/mem hazard (roman reigns)
        if (exmem_reg_write && (exmem_rd != 4'd0) &&
            (exmem_rd == idex_rs1))
            forward_a = 2'b10;
        
        if (exmem_reg_write && (exmem_rd != 4'd0) &&
            (exmem_rd == idex_rs2))
            forward_b = 2'b10;

        // mem/wb hazard
        if (memwb_reg_write && (memwb_rd != 4'd0) &&
            !(exmem_reg_write && (exmem_rd != 4'd0) &&
            (exmem_rd == idex_rs1)) &&
            (memwb_rd == idex_rs1))
            forward_a = 2'b01;
        
        if (memwb_reg_write && (memwb_rd != 4'd0) &&
            !(exmem_reg_write && (exmem_rd != 4'd0) &&
            (exmem_rd == idex_rs2)) &&
            (memwb_rd == idex_rs2))
            forward_b = 2'b01;
    end
endmodule

//idstage.v
`timescale 1ns/1ns
`include "def_opcode.v"

module id_stage(
    input wire clk,
    input wire rst,
    input wire  [15:0] instr,  // instr from IF stage

    input wire [15:0] wb_data,    // for write back
    input wire wb_reg_write,    // write enable from WB stage
    input wire [3:0] wb_rd,   //rd from WB stage\

    output reg [3:0] opcode,
    output reg [3:0] rd,
    output reg [3:0] rs1,
    output reg [3:0] rs2,
    output reg [15:0] rs1_data,
    output reg [15:0] rs2_data,
    output reg [15:0] imm,

    //control signals
    output reg reg_write,
    output reg alu_src,
    output reg mem_read,
    output reg mem_write,
    output reg mem_to_reg,
    output reg branch,
    output reg branch_ne,
    output reg halt,
    output reg [3:0] alu_op
);

    reg [15:0] regfile [0:15] ;

    integer i;
    always @( posedge clk or posedge rst ) begin
        if (rst) begin
            for (i=0; i<16; i=i+1)
                regfile[i] <= 16'b0;
        end
        else if (wb_reg_write && wb_rd != 4'd0) begin
            regfile[wb_rd] <= wb_data;   // write-back stage
        end
    end
    
    // decoding instruction
    always @(*) begin
        opcode = instr[15:12];
        rd = instr[11:8];
        rs1 = instr[7:4];
        rs2 = instr[3:0];
        imm = {{12{instr[3]}}, instr[3:0]}; // simple 4bit imm

        rs1_data = (rs1 == 4'd0) ? 16'd0 : regfile[rs1];
        rs2_data = (rs2 == 4'd0) ? 16'd0 : regfile[rs2];

        //default control signals bolte
        reg_write = 0;
        alu_src = 1'b0;
        mem_read = 1'b0;
        mem_write = 1'b0;
        mem_to_reg = 1'b0;
        branch = 1'b0;
        branch_ne =  1'b0;
        halt = 1'b0;
        alu_op = `ALU_ADD;

        case(opcode)
            //R-type 
            `OP_ADD : begin reg_write = 1 ; alu_op = `ALU_ADD; end
            `OP_SUB : begin reg_write = 1; alu_op = `ALU_SUB; end
            `OP_AND : begin reg_write = 1 ; alu_op = `ALU_AND; end
            `OP_OR : begin reg_write = 1; alu_op = `ALU_OR; end
            `OP_XOR : begin reg_write = 1; alu_op = `ALU_XOR; end
            `OP_SLT : begin reg_write = 1; alu_op = `ALU_SLT; end

            //I type
            `OP_ADDI : begin reg_write = 1; alu_src =1; alu_op = `ALU_ADD; end
            `OP_ANDI : begin reg_write = 1; alu_src =1; alu_op = `ALU_AND; end
            `OP_ORI : begin reg_write = 1; alu_src = 1; alu_op = `ALU_OR; end
            `OP_XORI : begin reg_write = 1; alu_src = 1; alu_op = `ALU_XOR; end

            //memory
            `OP_LW : begin reg_write = 1; alu_src =1 ; mem_read =1 ; mem_to_reg =1 ; alu_op = `ALU_ADD; end
            `OP_SW : begin alu_src =1 ; mem_write = 1; alu_op = `ALU_ADD; end

            //branch
            `OP_BEQ : begin branch =1; alu_op = `ALU_SUB; end
            `OP_BNE : begin branch =1; alu_op = `ALU_SUB; end

            //halt 
            `OP_HALT : begin halt =1 ; end
            default : begin /*eat 5 star - do nothing*/ end
    endcase
    end
endmodule

//ifstage.v
module if_stage(
    input wire clk,
    input wire rst,

    // control from hazard
    input wire stall_if, //PC stall hai
    input wire flush_if,  // flush branch pe / jump 
    input wire halt,   // halt ka instruction

    //branch ka control
    input wire branch_taken,
    input wire [15:0] branch_target,

    output wire [15:0] if_pc,
    output reg [15:0] if_instr
);

    wire [15:0] next_pc;
    wire pc_en;

    //pc enable logic 
    assign pc_en = (!stall_if) && (!halt);
    //next pc
    assign next_pc = branch_taken ? branch_target 
                                    : (if_pc + 16'd1);
    pc u_pc(
        .clk (clk),
        .rst (rst),
        .pc_en (pc_en),
        .next_pc ( next_pc),
        .pc_cur (if_pc)
    );

    wire [15:0] imem_instr;
    imem u_imem(
        .clk (clk),
        .addr (if_pc),
        .instr (imem_instr)
    );

    //output reg -- if stage
    always @(posedge clk or posedge rst ) begin
        if (rst) begin
            if_instr <= 16'hE000;   //NOP
        end
        else if (flush_if) begin
            if_instr <= 16'hE000;   //i will inject NOP on branch/jmp
        end
        else if (!stall_if && !halt) begin
            if_instr <= imem_instr;
        end
    end

endmodule

//imem.v
module imem(
    input wire clk,
    input wire rst,
    input wire stall,
    input wire [15:0] addr,    //word addressable
    output reg [15:0] instr
);

    reg [15:0] mem [0:65535];  // 64K x 16-bit memory...thats too much for imem, but whatever
    initial begin
        $readmemh("program.hex", mem);
    end

    //Synchronous read as FPGA BRAM style
    reg [15:0] instr_next;
    always @(*) begin
        instr_next = mem[addr];
    end

    always @(posedge clk or posedge rst ) begin
        if (rst) 
            instr <= 16'd0;
        else if (!stall)
            instr <= instr_next;
    end

endmodule

//pc.v
module pc(
    input wire clk,
    input wire rst,
    input wire pc_en,   // use for stall control
    input wire [15:0] next_pc ,
    output reg [15:0] pc_cur
);

    always @(posedge clk or posedge rst) begin
        if (rst) 
            pc_cur<= 16'd0;
        else if ( pc_en)
            pc_cur<=next_pc;
    end
endmodule

//pipeex2mem.v
`timescale 1ns/1ns

module pipe_ex2_mem (
    input wire clk,
    input wire rst,
    input wire flush_mem,
    input wire stall_mem,

    input wire [15:0] ex2_branch_target,
    output reg [15:0] mem_branch_target,
    
    // ex2 ips
    input wire [15:0] ex2_alu_result,
    input wire [15:0] ex2_rs2_data,   ///store karne ke liye
    input wire [3:0] ex2_rd,

    input wire ex2_reg_write,
    input wire ex2_mem_read,
    input wire ex2_mem_write,
    input wire ex2_mem_to_reg,
    input wire ex2_branch,
    input wire ex2_branch_ne,
    input wire ex2_zero,

    // mem ops
    output reg [15:0] mem_alu_result,
    output reg [15:0] mem_rs2_data,
    output reg [3:0]  mem_rd,

    output reg mem_reg_write,
    output reg mem_mem_read,
    output reg mem_mem_write,
    output reg mem_mem_to_reg,
    output reg mem_branch,
    output reg mem_branch_ne,
    output reg mem_zero
);

    always @(posedge clk or posedge rst ) begin
        if (rst) begin
            mem_alu_result <= 16'd0;
            mem_rs2_data <= 16'd0;
            mem_rd <= 4'd0;
            mem_branch_target <= 16'd0;
 
            mem_reg_write <= 1'b0;
            mem_mem_read <= 1'b0;
            mem_mem_write <= 1'b0;
            mem_mem_to_reg <= 1'b0;
            mem_branch <= 1'b0;
            mem_branch_ne <= 1'b0;
            mem_zero <= 1'b0;
        end
        else if (flush_mem) begin
            //flush on branch le liya
            mem_alu_result <= 16'd0;
            mem_rs2_data <= 16'd0;
            mem_rd <= 4'd0;
            mem_branch_target <= 16'd0;

            mem_reg_write <= 1'b0;
            mem_mem_read <= 1'b0;
            mem_mem_write <= 1'b0;
            mem_branch <= 1'b0;
            mem_branch_ne <= 1'b0;
            mem_zero <= 1'b0;
        
        end
        else if (!stall_mem) begin
            // normal transfer bw ex2-mem
            mem_alu_result <= ex2_alu_result;
            mem_rs2_data <= ex2_rs2_data;
            mem_rd <= ex2_rd;
            mem_branch_target <= ex2_branch_target;

            mem_reg_write <= ex2_reg_write;
            mem_mem_read <= ex2_mem_read;
            mem_mem_write <= ex2_mem_write;
            mem_mem_to_reg <= ex2_mem_to_reg;
            mem_branch <= ex2_branch;
            mem_branch_ne <= ex2_branch_ne;
            mem_zero <= ex2_zero;
        end
    end
endmodule
        
//pipeidex.v
module pipe_id_ex(
    input wire clk,
    input wire rst,
    input wire stall_ex,
    input wire flush_ex,

    input wire [15:0] id_pc,

    //data ips from ID stage
    input wire [15:0] id_rs1_data,
    input wire [15:0] id_rs2_data,
    input wire [15:0] id_imm,
    input wire[3:0] id_rd,
    input wire [3:0] id_rs1,
    input wire [3:0] id_rs2,

    // control signals from id stage
    input wire id_reg_write,
    input wire id_alu_src,
    input wire id_mem_read,
    input wire id_mem_write,
    input wire id_mem_to_reg,
    input wire id_branch,
    input wire id_branch_ne,
    input wire [3:0] id_alu_op,

    output reg [15:0] ex_pc,

    //outputs to ex stage
    output reg [15:0] ex_rs1_data,
    output reg [15:0] ex_rs2_data,
    output reg [15:0] ex_imm,
    output reg [3:0] ex_rd,
    output reg [3:0] ex_rs1,
    output reg [3:0] ex_rs2,

    output reg ex_reg_write,
    output reg ex_alu_src,
    output reg ex_mem_read,
    output reg ex_mem_write,
    output reg ex_mem_to_reg,
    output reg ex_branch,
    output reg ex_branch_ne,
    output reg [3:0] ex_alu_op
);

    always @(posedge clk or posedge rst) begin
        if( rst || flush_ex) begin
            //flushing ex stage
            ex_rs1_data <= 16'd0;
            ex_rs2_data <= 16'd0;
            ex_imm <= 16'd0;
            ex_rd <= 4'b0;
            ex_pc <= 16'd0;
            ex_rs1 <= 4'd0;
            ex_rs2 <= 4'd0;

            ex_reg_write <= 1'b0;
            ex_alu_src <= 1'b0;
            ex_mem_read <= 1'b0;
            ex_mem_write <= 1'b0;
            ex_mem_to_reg <= 1'b0;
            ex_branch <= 1'b0;
            ex_branch_ne <= 1'b0;
            ex_alu_op <= `ALU_ADD;
        end
        else if (!stall_ex) begin
            // we will apss signals from id to ex
            ex_rs1_data <= id_rs1_data;
            ex_rs2_data <= id_rs2_data;
            ex_imm <= id_imm;
            ex_rd <= id_rd;
            ex_pc <= id_pc;
            ex_rs1 <= id_rs1;
            ex_rs2 <= id_rs2;

            ex_reg_write <= id_reg_write;
            ex_alu_src <= id_alu_src;
            ex_mem_read <= id_mem_read;
            ex_mem_write <= id_mem_write;
            ex_mem_to_reg <= id_mem_to_reg;
            ex_branch <= id_branch;
            ex_branch_ne <= id_branch_ne;
            ex_alu_op <= id_alu_op;
        end
    end
endmodule

//pipeifid.v
module pipe_if_id (
    input wire clk,
    input wire rst,
    input wire stall_id,
    input wire flush_id,
    input wire [15:0] if_pc,
    input wire [15:0] if_instr,

    output reg [15:0] id_pc,
    output reg [15:0] id_instr
);

    always @( posedge clk or posedge rst) begin
        if ( rst) begin
            id_pc  <= 16'd0;
            id_instr <= 16'h0000;  // NOP 
        end 
        else if (flush_id)begin
            id_pc <= 16'd0;
            id_instr <= 16'h0000;
        end
        else if (!stall_id ) begin
            id_pc <= if_pc;
            id_instr <= if_instr;
        end
    end

endmodule

//pipememwb.v
`timescale 1ns/1ns

module pipe_mem_wb(
    input wire clk,
    input wire rst,
    input wire flush_wb,

    //ips from mem stage
    input wire [15:0] mem_alu_result,
    input wire [15:0] mem_read_data,
    input wire [3:0] mem_rd,

    input wire mem_reg_write,
    input wire mem_mem_to_reg,

    // ops to WB stage
    output reg [15:0] wb_alu_result,
    output reg [15:0] wb_read_data,
    output reg [3:0] wb_rd,

    output reg wb_reg_write,
    output reg wb_mem_to_reg
);

    always @(posedge clk or posedge rst ) begin
        if (rst || flush_wb) begin
            wb_alu_result <= 16'd0;
            wb_read_data <= 16'd0;
            wb_rd <= 4'd0;

            wb_reg_write <= 1'b0;
            wb_mem_to_reg <= 1'b0;
        end
        else begin
            wb_alu_result <= mem_alu_result;
            wb_read_data <= mem_read_data;
            wb_rd <= mem_rd;

            wb_reg_write <= mem_reg_write;
            wb_mem_to_reg <= mem_mem_to_reg;
        end
    end
endmodule 

//regfile.v
module regfile(
    input wire clk,
    input wire rst,
    input wire reg_write,
    input wire [3:0] rs1,
    input wire [3:0] rs2,
    input wire [3:0] rd,
    input wire [15:0] rd_data,
    output wire [15:0] rs1_data,
    output wire [15:0] rs2_data
);

    reg [15:0] regs [0:15];
    integer i;

    // WRITE (synchronous)
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (i = 0; i < 16; i = i + 1)
                regs[i] <= 16'd0;
        end else if (reg_write && rd != 4'd0) begin
            regs[rd] <= rd_data;
        end
    end

    wire [15:0] rs1_raw = (rs1==4'd0) ? 16'd0 : regs[rs1];
    wire [15:0] rs2_raw = (rs2==4'd0) ? 16'd0 : regs[rs2];
    assign rs1_data = (reg_write && (rd==rs1) && (rd != 4'd0)) ? rd_data : rs1_raw;
    assign rs2_data = (reg_write && (rd==rs2) && (rd != 4'd0)) ? rd_data : rs2_raw;

endmodule

//python script
program_file = "program.hex"
with open(program_file, "r") as f:
    lines = [line.strip() for line in f.readlines() if line.strip()]

instructions = [line.zfill(4) for line in lines]

reg_count = 16
mem_count =16
registers = [0]*reg_count
memory = [0]*mem_count

pipeline = {
    "IF" : None,
    "ID" : None,
    "EX" : None,
    "WB" : None
}

pc = 0
time =0
Step = 10

nop = "0000"

def decode(instr) :
    if instr in (nop, "xxxx", None) :
        return None, None, None, None
    op = int(instr[0], 16)
    rd = int(instr[1],16)
    rs1 = int(instr[2],16)
    rs2 = int(instr[3],16)
    return op, rd, rs1, rs2

def execute(op,rs1_val,rs2_val) :
    if op == 1:
        return (rs1_val+rs2_val) & 0xFFFF
    elif op == 2 :
        return (rs1_val-rs2_val) & 0xFFFF
    elif op == 3:
        return rs1_val & rs2_val
    elif op ==4 :
        return rs1_val | rs2_val
    elif op == 5:
        return memory[rs2_val %mem_count]
    elif op == 6:
        memory[rs2_val %mem_count] = rs1_val
        return None
    elif op == 7:
        return rs2_val
    else :
        return 0

def hazard_stall(id_instr, ex_instr) :
    if not id_instr or id_instr in (nop, "xxxx") :
        return False
    if not ex_instr or ex_instr in (nop, "xxxx" ) :
        return False
    _, id_rd, id_rs1, id_rs2 = decode(id_instr)
    _, ex_rd, _, _ = decode(ex_instr if isinstance(ex_instr, str) else ex_instr.get('instr', nop))
    if ex_rd in (id_rs1, id_rs2) and ex_rd !=0 :
        return True
    return False

def print_snapshot(time, pc, pipeline) :
    # EX_RD
    if pipeline['EX'] and isinstance(pipeline['EX'], dict):
        ex_rd = pipeline['EX']['rd'] if isinstance(pipeline['EX'], dict) else 0
    else:
        ex_rd = 0

    # WB_RD
    if pipeline['WB'] and isinstance(pipeline['WB'], dict):
        wb_rd = pipeline['WB']['rd'] if isinstance(pipeline['WB'], dict) else 0
    else:
        wb_rd = 0

    # WB_W
    wb_w = 1 if isinstance(pipeline['WB'], dict) else 0

    # ID_INSTR
    id_instr = pipeline['ID'] if pipeline['ID'] else "0000"
    print(f"T={time :<5} | IF_PC={pc : 04x} | ID_INSTR={id_instr} | EX_RD={ex_rd} | WB_RD={wb_rd} | WB_W={wb_w}")

def print_registers() :
    print("\n=== REGISTER FILE ===")
    for i in range(reg_count) :
        print(f"R{i} = {registers[i]:04x} ({registers[i]})")
    print("\n=== DATA MEMORY [0..7] ===")
    for i in range(8):
        print(f"mem[{i}] = {memory[i]:04x}")

sim_cycles = 100
for t in range(sim_cycles) :
    time += Step

    if pipeline['WB'] and isinstance(pipeline['WB'], dict) :
        rd = pipeline['WB']['rd']
        val = pipeline['WB']['alu_res']
        if rd is not None and rd!=0 and val is not None :
            registers[rd] = val

    if pipeline['EX']  and pipeline['EX'] not in (nop, "xxxx") :
        instr = pipeline['EX']['instr'] if isinstance(pipeline['EX'], dict) else pipeline['EX']
        op, rd, rs1, rs2 = decode (instr)
        if op is not None :
            rs1_val = registers[rs1]
            rs2_val = registers[rs2]
            alu_res = execute(op, rs1_val, rs2_val)
            pipeline['EX'] = {"rd" :rd, "alu_res": alu_res, "instr" : instr}

            if op ==7 :
                pc = alu_res
                pipeline ['IF'] = nop
                pipeline['ID'] = nop

    ex_instr_str = pipeline['EX']['instr'] if isinstance(pipeline['EX'], dict) else pipeline['EX']
    stall = hazard_stall(pipeline['ID'], ex_instr_str)
    if not stall :
        pipeline['WB'] = pipeline['EX']
        pipeline['EX'] = pipeline['ID']
        pipeline['ID'] = pipeline['IF']
        if pc < len(instructions) :
            pipeline['IF'] = instructions[pc]
        else :
            pipeline['IF'] = nop
        pc +=1
    else :
        pipeline['WB'] = pipeline['EX']
        pipeline['EX'] = {"rd" : 0, "alu_res" : 0, "instr" : nop}

    print_snapshot(time, pc, pipeline)

print_registers()